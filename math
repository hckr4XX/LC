# 01


count digits

1. brute force:

    #include <stdio.h>
    
    int main() {
        int N;
        int count = 0;
    
        scanf("%d", &N);
    
        if(N == 0) {  // special case for 0
            count = 1;
        } else {
            if(N < 0) N = -N;  // make N positive if it's negative
            while(N > 0) {
                N = N / 10;  // remove last digit
                count++;     // increment count
            }
        }
    
        printf("%d\n", count);
        return 0;
    }


COMPLEXITY:

TIME: O(log10N + 1) cuz while loop executes till 0; each time divide by 10 to extract last digit and +1 for constant operation like incrementing
SPACE: O(1) cuz only one output var to store the length



2. optimal


    #include <stdio.h>
    #include <math.h>
    
    int main() {
        int N;
        scanf("%d", &N);
    
        if(N == 0) {
            printf("1\n");
        } else {
            int digits = (int)log10(abs(N)) + 1;
            printf("%d\n", digits);
        }
    
        return 0;
    }
    


The number of digits of N = smallest integer greater than log10(N)

Mathematically: digits=⌊log10(N)⌋+1

Why +1?

log10(N) gives 4.091 → floor = 4 → add 1 → 5 digit



COMPLEXITY:

TIME: O(1) cuz simple arithmetic constant operation
SPACE: O(1) cuz only one output var to store the length





#02


rev an integer


            int reverse(int x) {
                int rev = 0;
            
                while (x != 0) {
                    int dig = x % 10;
            
                    // overflow check
                    if (rev > 214748364 || (rev == 214748364 && dig > 7))
                        return 0;
                    if (rev < -214748364 || (rev == -214748364 && dig < -8))
                        return 0;
            
                    rev = rev * 10 + dig;
                    x /= 10;
                }
            
                return rev;
            }


x!=0 ->handles negative nos also
Integer limits in C (32-bit)
INT_MAX =  2147483647
INT_MIN = -2147483648

this is to avoid integer overflow






#03 

palindrome



        bool isPalindrome(int x) {
            // negative numbers or numbers ending with 0 (except 0 itself) can't be palindromes
            if (x < 0 || (x % 10 == 0 && x != 0))
                return false;
        
            int rev = 0;
        
            while (x > rev) {
                rev = rev * 10 + x % 10;
                x /= 10;
            }
        
            // for even digits: x == rev
            // for odd digits:  x == rev/10
            return (x == rev || x == rev / 10);
        }



A palindrome reads the same forward and backward

So you only need to reverse half of it

This completely avoids overflow



Why this works (example)
Input:
x = 12321


Steps:

x = 12321, rev = 0
x = 1232 , rev = 1
x = 123  , rev = 12
x = 12   , rev = 123   ← stop (x <= rev)


Now:

odd length → drop middle digit
12 == 123/10 ✔

Input:
x = 1221

x = 12, rev = 12

x == rev ✔


TIME: O(N/2)
SPACE: O(1)




